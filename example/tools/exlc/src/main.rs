use anyhow::{bail, Context, Result};
use clap::{Parser, Subcommand};
use regex::Regex;
use serde::Deserialize;
use std::collections::HashSet;
use std::fs;
use std::path::{Path, PathBuf};
use std::process::Command;
use which::which;

/// exlc: Exline prototype compiler
#[derive(Parser, Debug)]
#[command(version, about = "Exline prototype compiler (Rust)")]
struct Cli {
    /// Commands: build (default), run, clean
    #[command(subcommand)]
    command: Option<Cmd>,
}

#[derive(Subcommand, Debug)]
enum Cmd {
    /// Translate src/main.exl to Rust and compile with rustc
    Build,
    /// Build then run the produced binary
    Run,
    /// Remove target artifacts
    Clean,
}

#[derive(Deserialize, Debug)]
struct Manifest {
    package: Package,
}

#[derive(Deserialize, Debug)]
struct Package {
    name: String,
    version: String,
    edition: Option<String>,
}

fn main() -> Result<()> {
    let cli = Cli::parse();
    let cmd = cli.command.unwrap_or(Cmd::Build);
    match cmd {
        Cmd::Build => build(None),
        Cmd::Run => {
            build(None)?;
            run(None)
        }
        Cmd::Clean => clean(None),
    }
}

fn project_root(start: Option<&Path>) -> Result<PathBuf> {
    let mut dir = start
        .map(PathBuf::from)
        .unwrap_or(std::env::current_dir()?);
    loop {
        if dir.join("Exline.toml").exists() {
            return Ok(dir);
        }
        if !dir.pop() {
            bail!("Could not find Exline.toml in current or parent directories");
        }
    }
}

fn read_manifest(root: &Path) -> Result<Manifest> {
    let toml_text =
        fs::read_to_string(root.join("Exline.toml")).context("reading Exline.toml")?;
    let manifest: Manifest = toml::from_str(&toml_text).context("parsing Exline.toml")?;
    Ok(manifest)
}

/// Very small translator that supports:
/// - def main ... end
/// - variable assignment:   name = "Exline"
/// - print with interpolation:  print "Hello, #{name}!"
fn transpile_exline_to_rust(src: &str) -> Result<String> {
    let main_re = Regex::new(r"(?s)def\s+main\s*(?P<body>.*?)\bend\b")?;
    let caps = main_re
        .captures(src)
        .context("could not find `def main ... end` in source")?;
    let body = caps.name("body").unwrap().as_str();

    let assign_re = Regex::new(r#"^\s*([A-Za-z_]\w*)\s*=\s*"([^"]*)"\s*$"#)?;
    let print_re  = Regex::new(r#"^\s*print\s+"(.*)"\s*$"#)?;

    let mut rust_body = String::new();
    let mut declared: HashSet<String> = HashSet::new();

    for (lineno, line) in body.lines().enumerate() {
        let trimmed = line.trim();
        if trimmed.is_empty() { continue; }

        if let Some(c) = assign_re.captures(line) {
            let var = c.get(1).unwrap().as_str().to_string();
            let val = c.get(2).unwrap().as_str().replace(r#"""#, r#"\""#);
            if declared.contains(&var) {
                rust_body.push_str(&format!(r#"    {var} = String::from("{val}"); // line {}"#, lineno+1));
                rust_body.push('\n');
            } else {
                rust_body.push_str(&format!(r#"    let mut {var} = String::from("{val}"); // line {}"#, lineno+1));
                rust_body.push('\n');
                declared.insert(var);
            }
            continue;
        }

        if let Some(c) = print_re.captures(line) {
            let raw = c.get(1).unwrap().as_str();
            let (fmt, args) = interpolate_to_rust_format(raw);
            if args.is_empty() {
                rust_body.push_str(&format!(r#"    println!("{fmt}"); // line {lineno}"#));
            } else {
                let args_join = args.iter().map(|a| format!("&{}", a)).collect::<Vec<_>>().join(", ");
                rust_body.push_str(&format!(r#"    println!("{fmt}", {args_join}); // line {lineno}"#));
            }
            rust_body.push('\n');
            continue;
        }

        bail!("Unsupported statement in main (line {}): `{}`", lineno+1, trimmed);
    }

    let rust_program = format!(
r#"// Auto-generated by exlc (prototype)
fn main() {{
{}
}}
"#,
        rust_body
    );
    Ok(rust_program)
}

/// Parse interpolation markers #{ident} in a string, returning a Rust format string and arg names.
fn interpolate_to_rust_format(s: &str) -> (String, Vec<String>) {
    let mut fmt = String::new();
    let mut args: Vec<String> = Vec::new();
    let mut i = 0;
    let bytes = s.as_bytes();
    while i < bytes.len() {
        let ch = bytes[i] as char;
        if ch == '#' && i + 1 < bytes.len() && bytes[i+1] as char == '{' {
            i += 2;
            let start = i;
            while i < bytes.len() && bytes[i] as char != '}' { i += 1; }
            if i >= bytes.len() {
                fmt.push_str("#{");
                break;
            }
            let ident = &s[start..i].trim();
            fmt.push_str("{}");
            args.push(ident.to_string());
            i += 1; // skip '}'
        } else {
            if ch == '{' || ch == '}' {
                fmt.push(ch);
                fmt.push(ch);
            } else {
                fmt.push(ch);
            }
            i += 1;
        }
    }
    (fmt, args)
}

fn build(start: Option<&Path>) -> Result<()> {
    let rustc = which("rustc").context("`rustc` not found in PATH. Please install Rust.")?;
    let root = project_root(start)?;
    let manifest = read_manifest(&root)?;
    let src_path = root.join("src/main.exl");
    let src_text = fs::read_to_string(&src_path)
        .with_context(|| format!("reading {}", src_path.display()))?;

    let out_dir = root.join("target/gen");
    fs::create_dir_all(&out_dir)?;
    let rust_code = transpile_exline_to_rust(&src_text)?;
    let rust_out = out_dir.join("main.rs");
    fs::write(&rust_out, rust_code)?;

    let bin_out = root.join("target").join(&manifest.package.name);
    let status = Command::new(rustc)
        .arg(&rust_out)
        .arg("-O")
        .arg("-o")
        .arg(&bin_out)
        .status()
        .context("invoking rustc")?;
    if !status.success() {
        bail!("rustc failed");
    }
    println!("Built {}", bin_out.display());
    Ok(())
}

fn run(start: Option<&Path>) -> Result<()> {
    let root = project_root(start)?;
    let manifest = read_manifest(&root)?;
    let bin = root.join("target").join(&manifest.package.name);
    if !bin.exists() {
        build(Some(&root))?;
    }
    let status = Command::new(&bin).status().context("running binary")?;
    if !status.success() {
        bail!("program exited with non-zero status");
    }
    Ok(())
}

fn clean(start: Option<&Path>) -> Result<()> {
    let root = project_root(start)?;
    let target = root.join("target");
    if target.exists() {
        fs::remove_dir_all(&target)?;
        println!("Removed {}", target.display());
    } else {
        println!("Nothing to clean");
    }
    Ok(())
}
